En el First al ejecutarlo siempre sale Number of processes in critical section: 1
¬øQu√© falla aqu√≠?

1Ô∏è‚É£ No hay exclusi√≥n mutua real

Este c√≥digo supone que s√≥lo entra 1 proceso a la vez, pero eso depende de atomicidad, y aqu√≠ nada es at√≥mico.
Mira esta secuencia posible:
    P comprueba turn == 1 ‚Üí es cierto
    Se interrumpe justo antes de hacer inCS++
    Q cambia turn = 1
    Q tambi√©n entra ‚Üí porque turn == 2 en alg√∫n momento y luego turn == 2 cambia mal
    Ambos llegan a la secci√≥n cr√≠tica.

Resultado: dos hilos dentro, exclusi√≥n mutua violada.
Esto es precisamente lo que la asignatura suele querer demostrar.

2Ô∏è‚É£ Thread.yield() NO sincroniza

Como te dije antes, yield() es una sugerencia, no un bloqueo.

Puede dejar de ejecutarse‚Ä¶ o no.

‚Üí Es impredecible y no garantiza orden de ejecuci√≥n.
‚Üí No evita condiciones de carrera.
‚Üí No sirve para proteger una secci√≥n cr√≠tica.

3Ô∏è‚É£ inCS++ y inCS-- NO son at√≥micos

Estas operaciones requieren tres pasos:
Leer el valor
Incrementar
Escribir el valor
Si entran dos hilos simult√°neamente ‚Üí uno pisa el valor del otro.

4Ô∏è‚É£ Turnos mal gestionados

El algoritmo correcto de Peterson usa dos banderas + turno, no solo un turno.
Aqu√≠ falta:
flag[i] = true;
turn = j;
Esperar mientras flag[j] && turn == j
Sin esas banderas no hay espera mutua.

¬øPor qu√© falla el Second Attempt?
El problema es el orden de operaciones:


El  Second
1Ô∏è‚É£ Comprobaci√≥n de wantq se hace antes de poner wantp = true

Caso:

P ejecuta:
while (wantq) yield();
‚Üí En ese momento, wantq == false, as√≠ que P NO espera.

Antes de que P ejecute wantp = true, el sistema hace un cambio de contexto.

Q ejecuta:
while (wantp) yield();
‚Üí wantp == false (porque P a√∫n no lo puso a true), as√≠ que Q TAMPOCO espera.

Q hace wantq = true y entra a la secci√≥n cr√≠tica.

Cambio de contexto.

P hace wantp = true y tambi√©n entra.

‚û°Ô∏è Ambos procesos entran en la secci√≥n cr√≠tica simult√°neamente.

El third:
¬øD√≥nde falla el Third Attempt? (Interbloqueo)

El error es que si ambos procesos activan su bandera casi al mismo tiempo, pasa esto:
P ejecuta: wantp = true;
Cambio de contexto
Q ejecuta: wantq = true;
Ahora:
P bloqueado en while (wantq)
Q bloqueado en while (wantp)
‚û°Ô∏è Ambos esperan eternamente
‚û°Ô∏è Interbloqueo (deadlock)
‚û°Ô∏è Nadie entra en la secci√≥n cr√≠tica

El fourth:
‚ùó Falla la exclusi√≥n mutua ‚Üí dos procesos pueden entrar a la vez
¬øC√≥mo?
Si ambos ejecutan esto a la vez:

P pone wantp = false

Q pone wantq = false

Entonces:

‚û°Ô∏è Cada uno mira la bandera del otro
‚û°Ô∏è Ambas son false
‚û°Ô∏è Ambos salen del bucle
‚û°Ô∏è Ambos entran en la secci√≥n cr√≠tica al mismo tiempo

üí• Violaci√≥n de exclusi√≥n mutua